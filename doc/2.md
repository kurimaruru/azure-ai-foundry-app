# プロジェクトのセットアップと基本的なコンポーネントの作成

## 1. プロジェクトのセットアップ

### 1.1 プロジェクトの作成

以下の手順で新しいNext.jsプロジェクトを作成します：

1. 以下のリンクをクリック

https://codesandbox.io/p/sandbox/next-js-app-router-tailwindcss-javascript-gkkncr

2. 以下のような画面が開いたら左側のGithubアイコンをクリックし、「Create repository」を選択します。

3. Repository nameを入力し、Create repositoryを押下する。
このとき、作成したリポジトリは自分のアカウントのプライベートリポジトリとして新規作成されます。

    またGithubで管理する目的として、以下のような理由があります。
    - 作成したコードをいつでも振り返れるように
    - Githubでコード管理すると、CodeSandboxの「devbox」というプロジェクトを仮想マシンで動かすための環境を利用することができるようになります。
    - Azure AI Foundryを利用するうえでdevboxだと環境変数を安全に取り扱えることができるようになるためdevboxを今回は利用します。

![react](image1.png)

以下のような画面が表示されるので、少し待機します。
![react](image2.png)

Create repositoryをした後は以下のような画面が自動で表示されます。
そのまま「Universal Template」を選択したままNextを選択します。

![react](image16.png)

Step2も何も変更せずにNextをクリック

Step3もいったん何も設定せずにNextを押下していただきますが、後ほど環境変数は設定します。

Step4 , Step5も何も変更せずにNextをクリック

Step6まできたら、Applyをクリックする。

### 1.2 Preview画面が開けるか確認

![react](image3.png)

画面右側にNext.jsのプレビュー画面が表示されればOKです。

![react](image4.png)


## 2. 基本的なコンポーネントの作成

### 2.1 各コンポーネントの基本実装

#### TaskForm.jsx
##### まずは`src/app/page.js`を編集します。

```jsx
'use client';

import React from 'react';
import { useTaskManager } from '../hooks/useTaskManager';
import TaskForm from '../components/TaskForm';

const App = () => {
  const { addTask } = useTaskManager();
  return (
    <div className="mx-auto flex max-w-2xl flex-col items-center rounded-lg bg-white p-4 shadow">
      <h1 className="mb-4 text-2xl font-bold">タスク管理アプリ</h1>
      <TaskForm onAddTask={addTask} />
    </div>
  );
};

export default App;

```

##### 基本構造
###### `'use client'`について

Next.jsでは、'use client';はコンポーネントやモジュールがクライアントサイド（ブラウザ）で実行されることを宣言するディレクティブです。

Next.js 13以降では、デフォルトでサーバーコンポーネントが採用されています。サーバーコンポーネントはサーバー上で実行され、HTMLとしてクライアントに送信されます。これに対して、'use client';と宣言したファイルはクライアントコンポーネントとなり、ブラウザ上で実行されます。

クライアントコンポーネントは以下の場合に使用します：
- インタラクティブな機能が必要なとき（useState, useEffectなど）
- ブラウザAPIにアクセスする必要があるとき（localStorage, windowオブジェクトなど）
- イベントリスナーを使用するとき（onClick, onChangeなど）

ファイルの先頭に'use client';を記述することで、そのファイルとそれがインポートするすべてのモジュールがクライアントバンドルの一部となります。

###### `import`について
- import { useTaskManager } from '../hooks/useTaskManager';：

  相対パスで../hooks/useTaskManagerから後ほど作成するuseTaskManagerフックをインポートしています
このようなカスタムフックは通常、状態管理や副作用のロジックをカプセル化します


- import TaskForm from '../components/TaskForm';：

  相対パスで../components/TaskFormから後ほど作成するTaskFormコンポーネントをインポートしています

`src/hooks/useTaskManager.js`の編集をします。

まずはsrc配下にhooksフォルダを作成する。

その次にhooksフォルダ配下にuseTaskManager.jsファイルを作成する。
```javascript
import { useState, useEffect } from "react";

export const useTaskManager = () => {
  const [tasks, setTasks] = useState(() => {
    const savedTasks = localStorage.getItem("tasks");
    return savedTasks ? JSON.parse(savedTasks) : [];
  });

  useEffect(() => {
    localStorage.setItem("tasks", JSON.stringify(tasks));
  }, [tasks]);

  const addTask = (title, description = "", dueDate = "") => {
    if (!title.trim()) return;

    const newTask = {
      id: Date.now(),
      title,
      description,
      dueDate,
      completed: false,
    };

    setTasks([...tasks, newTask]);
  };

  return { addTask };
};

```


##### 基本的な機能
- useTaskManagerフックは次のことができます：
- タスクのリストを管理する
- ローカルストレージにタスクを保存する
- 新しいタスクを追加する

##### コードの詳細説明
インポート部分

```javascript
import { useState, useEffect } from "react";
```

- useState: データを保存・更新するためのReactフック
- useEffect: 副作用（画面更新以外の処理）を扱うためのReactフック

フックの定義
```javascript
export const useTaskManager = () => {
  // ここに中身が入ります
};
```
このようにuseで始まる関数がカスタムフックです。これを使うと、コードを再利用しやすくなります。


タスク状態の初期化

```javascript
const [tasks, setTasks] = useState(() => {
  const savedTasks = localStorage.getItem("tasks");
  return savedTasks ? JSON.parse(savedTasks) : [];
});
```
ここでは：

useStateの中で関数を使っています（これを「遅延初期化」と言います）
ブラウザのlocalStorageからタスク情報を取得しています
もし保存されたタスクがあれば、それをJSON.parseで通常のオブジェクトに変換
なければ空の配列[]を初期値とします

自動保存の設定
```javascript
useEffect(() => {
  localStorage.setItem("tasks", JSON.stringify(tasks));
}, [tasks]);
```

ここでは：

useEffectを使って「副作用」を実行しています
tasksが変わるたびに実行されます（[tasks]の部分がそれを指定しています）
タスク配列を文字列に変換して(JSON.stringify)ローカルストレージに保存しています

タスク追加関数

```javascript
const addTask = (title, description = "", dueDate = "") => {
  if (!title.trim()) return; 

  const newTask = {
    id: Date.now(), 
    title,          
    description,     
    dueDate,         
    completed: false, 
  };

  setTasks([...tasks, newTask]); 
};
```

ここでは：

タスクを追加する関数を定義しています
必須なのはtitleだけで、他のパラメータはオプションです
タイトルが空白だけの場合は早期リターンで処理終了
新しいタスクオブジェクトを作成
setTasksで状態を更新（[...tasks, newTask]は既存の配列にnewTaskを追加する構文）


`src/App.jsx`で呼び出す`src/components/TaskForm.jsx`コンポーネントを作成します。



```jsx
import React, { useState } from "react";

const TaskForm = ({ onAddTask }) => {
  const [newTaskTitle, setNewTaskTitle] = useState("");
  const [description, setDescription] = useState("");
  const [dueDate, setDueDate] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!newTaskTitle.trim() || !description.trim() || !dueDate) {
      return;
    }
    onAddTask(newTaskTitle, description, dueDate);
    setNewTaskTitle("");
    setDescription("");
    setDueDate("");
  };

  return (
    <form onSubmit={handleSubmit} className="w-full mb-6">
      <div className="flex mb-2">
        <input
          type="text"
          value={newTaskTitle}
          onChange={(e) => setNewTaskTitle(e.target.value)}
          placeholder="タスクのタイトルを入力..."
          className="flex-grow p-2 border border-gray-300 rounded-l focus:outline-none"
          required
        />
        <div className="p-2 border border-gray-300 rounded-l focus:outline-none">
          期限
        </div>
        <input
          type="date"
          value={dueDate}
          onChange={(e) => setDueDate(e.target.value)}
          className="p-2 border border-gray-300 focus:outline-none"
          required
        />
        <button
          type="submit"
          className="bg-blue-500 text-white px-4 py-2 rounded-r hover:bg-blue-600"
        >
          追加
        </button>
      </div>
      <textarea
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        placeholder="タスクの詳細を入力..."
        className="w-full p-2 border border-gray-300 rounded focus:outline-none"
        rows="2"
        required
      />
    </form>
  );
};

export default TaskForm;
```


このフォームコンポーネントでは：

- タスクのタイトル入力欄
- タスクの詳細（説明）入力欄
- 期限日の選択欄
- 追加ボタン

を提供しています。


コンポーネントの定義

```jsx
const TaskForm = ({ onAddTask }) => {
  // 中身はこの後に続きます
};
```

TaskFormは関数コンポーネントです

{ onAddTask }は、親コンポーネントから渡される関数（props）です

このコンポーネントで新しいタスクを追加するときに呼び出す関数です



状態（state）の管理

```jsx
const [newTaskTitle, setNewTaskTitle] = useState("");
const [description, setDescription] = useState("");
const [dueDate, setDueDate] = useState("");
ここでは3つの状態を管理しています：

newTaskTitle: タスクのタイトル（初期値は空文字）
description: タスクの詳細説明（初期値は空文字）
dueDate: タスクの期限日（初期値は空文字）
```

それぞれに対応する更新関数（setNewTaskTitleなど）も用意されています。

フォーム送信処理
```jsx
const handleSubmit = (e) => {
  e.preventDefault();
  if (!newTaskTitle.trim() || !description.trim() || !dueDate) {
    return;
  }
  onAddTask(newTaskTitle, description, dueDate);
  setNewTaskTitle("");
  setDescription("");
  setDueDate("");
};
```

ここでは：

- 入力チェック: タイトルか説明が空白だけ、または期限日が未設定の場合は何もせず処理を終了
- onAddTask: 親から受け取った関数を呼び出して、新しいタスクを追加
- 各フィールドをリセット: 入力欄を空にして次の入力に備える



##### 画面確認
ここまで実装できたら、実装した画面を確認してみましょう。
タスク登録フォームが表示されていればOKです！試しにタスクを追加してみてください。
![react](image6.png)

#### TaskList.jsx
TaskListコンポーネントを追加し、`src/App.jsx`を更新します。

```jsx
'use client';

import React from 'react';
import { useTaskManager } from '../hooks/useTaskManager';
import TaskForm from '../components/TaskForm';
import TaskList from "../components/TaskList"; // 追加

const App = () => {
  const { addTask, tasks, updateTask, deleteTask, toggleComplete } = useTaskManager();
  return (
    <div className="mx-auto flex max-w-2xl flex-col items-center rounded-lg bg-white p-4 shadow">
      <h1 className="mb-4 text-2xl font-bold">タスク管理アプリ</h1>
      <TaskForm onAddTask={addTask} />
      {/* TaskListの追加 */}
      <TaskList
        tasks={tasks}
        onToggleComplete={toggleComplete}
        onDelete={deleteTask}
        onUpdate={updateTask}
      />
    </div>
  );
};

export default App;

```


`src/hooks/useTaskManager.js`の編集をします。
```javascript
import { useState, useEffect } from "react";

export const useTaskManager = () => {
  const [tasks, setTasks] = useState(() => {
    const savedTasks = localStorage.getItem("tasks");
    return savedTasks ? JSON.parse(savedTasks) : [];
  });

  useEffect(() => {
    localStorage.setItem("tasks", JSON.stringify(tasks));
  }, [tasks]);

  const addTask = (title, description = "", dueDate = "") => {
    if (!title.trim()) return;

    const newTask = {
      id: Date.now(),
      title,
      description,
      dueDate,
      completed: false,
    };

    setTasks([...tasks, newTask]);
  };

  // ------------追加ここから-----------------
  const updateTask = (id, updates) => {
    setTasks(
      tasks.map((task) => (task.id === id ? { ...task, ...updates } : task))
    );
  };

  const deleteTask = (id) => {
    setTasks(tasks.filter((task) => task.id !== id));
  };

  const toggleComplete = (id) => {
    setTasks(
      tasks.map((task) =>
        task.id === id ? { ...task, completed: !task.completed } : task
      )
    );
  };
  // ------------追加ここまで-----------------

  return { 
    addTask,
    // tasks,deleteTask,toggleComplete,updateTaskの追加
    tasks,
    deleteTask,
    toggleComplete,
    updateTask, 
  };
};

```

##### 追加したコードの説明
1. updateTask関数 - タスク更新機能
```javascript
const updateTask = (id, updates) => {
  setTasks(
    tasks.map((task) => (task.id === id ? { ...task, ...updates } : task))
  );
};
```

##### 機能
- 特定のタスクの内容（タイトル、説明、期限など）を更新します。

##### 詳しい解説
- id: 更新したいタスクのID
- updates: 変更したい情報を含むオブジェクト（例: { title: "新しいタイトル" }）
- tasks.map(): 全タスクの配列を1つずつ処理します
- 三項演算子 ? : を使って：
  - もし現在のタスクIDが更新対象のIDと一致したら → そのタスクを更新
  - 一致しなければ → そのタスクをそのまま返す
- { ...task, ...updates }: スプレッド構文で既存のタスク情報を展開し、その上に更新情報を上書きします


具体例
```javascript
// ID=123のタスクのタイトルと説明を更新
updateTask(123, { title: "買い物リスト修正", description: "野菜も買う" });
```

#### 2. deleteTask関数 - タスク削除機能
```javascript
const deleteTask = (id) => {
  setTasks(tasks.filter((task) => task.id !== id));
};
```

##### 機能
- 特定のIDのタスクを削除します。

##### 詳しい解説
- id: 削除したいタスクのID
- tasks.filter(): 条件に合うタスクだけを残して新しい配列を作ります
- task.id !== id: 「タスクのIDが削除対象のIDと異なる」という条件
  - この条件に合うタスクだけが残り、指定したIDのタスクは除外されます
  - これによって、指定したIDのタスクを含まない新しい配列が作られ、それが新しい状態になります

#### 3. toggleComplete関数 - 完了状態切り替え機能
```javascript
const toggleComplete = (id) => {
  setTasks(
    tasks.map((task) =>
      task.id === id ? { ...task, completed: !task.completed } : task
    )
  );
};
```

##### 機能
- タスクの完了状態（完了/未完了）を切り替えます。

##### 詳しい解説
- id: 状態を切り替えたいタスクのID
- tasks.map(): 全タスクの配列を1つずつ処理します
- 三項演算子 ? : を使って：
  - もし現在のタスクIDが対象のIDと一致したら → 完了状態を反転
  - 一致しなければ → そのタスクをそのまま返す
- { ...task, completed: !task.completed }:
  - ...task: 既存のタスク情報を全て展開
  - completed: !task.completed: 完了状態を反転（trueならfalseに、falseならtrueに）


`src/components/TaskList.jsx`を編集します。

components配下にTaskList.jsxファイルを作成してください。
```jsx
import React from "react";
import TaskItem from "./TaskItem";

const TaskList = ({ tasks, onToggleComplete, onDelete, onUpdate }) => {
  return (
    <ul className="w-full">
      {tasks.length === 0 ? (
        <li className="p-4 text-center text-gray-500">タスクがありません</li>
      ) : (
        tasks.map((task) => (
          <TaskItem
            key={task.id}
            task={task}
            onToggleComplete={onToggleComplete}
            onDelete={onDelete}
            onUpdate={onUpdate}
          />
        ))
      )}
    </ul>
  );
};

export default TaskList;
```

#### 基本的な機能

TaskListコンポーネントの主な機能は：
- 複数のタスクを一覧表示する
- タスクがない場合に適切なメッセージを表示する
- 各タスクをTaskItemコンポーネントに渡して表示する

#### コンポーネントの定義
```jsx
const TaskList = ({ tasks, onToggleComplete, onDelete, onUpdate }) => {
  // 中身はこの後に続きます
};
```

このコンポーネントは4つのprops（プロパティ）を受け取ります：
- tasks: タスクの配列（一覧表示するデータ）
- onToggleComplete: タスクの完了状態を切り替える関数
- onDelete: タスクを削除する関数
- onUpdate: タスクを更新する関数

#### 条件付きレンダリング
```jsx
{tasks.length === 0 ? (
  <li className="p-4 text-center text-gray-500">タスクがありません</li>
) : (
  tasks.map((task) => (
    <TaskItem
      key={task.id}
      task={task}
      onToggleComplete={onToggleComplete}
      onDelete={onDelete}
      onUpdate={onUpdate}
    />
  ))
)}
```

ここでは三項演算子（条件 ? 真の場合 : 偽の場合）を使って：
- もしタスクの配列が空（長さが0）の場合：
  - 「タスクがありません」というメッセージを表示
  - text-gray-500でテキストを灰色に
  - text-centerでテキストを中央寄せに
- タスクが1つ以上ある場合：
  - tasks.map()でタスクの配列を繰り返し処理
  - 各タスクに対してTaskItemコンポーネントを表示
  - 必要なpropsを子コンポーネントに渡す

#### TaskItemへのprops受け渡し
```jsx
<TaskItem
  key={task.id}
  task={task}
  onToggleComplete={onToggleComplete}
  onDelete={onDelete}
  onUpdate={onUpdate}
/>
```

- key={task.id}: Reactのリスト表示で必要な一意のキー（パフォーマンス最適化のため）
- task={task}: 現在処理中のタスクオブジェクトを渡す
- 残りの3つのprops: 親から受け取った関数をそのまま子コンポーネントに渡す

このコンポーネントは「コンテナ」的な役割を果たし、実際のタスク表示や操作は子コンポーネントであるTaskItemに委ねています。これは「単一責任の原則」に基づいています。

`src/components/TaskItem.jsx`を編集します。

components配下にTaskItem.jsxファイルを作成してください。
```jsx
import React, { useState } from 'react';

const TaskItem = ({ task, onToggleComplete, onDelete, onUpdate }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editTitle, setEditTitle] = useState(task.title);
  const [editDescription, setEditDescription] = useState(task.description);
  const [editDueDate, setEditDueDate] = useState(task.dueDate);

  const handleSave = () => {
    onUpdate(task.id, {
      title: editTitle,
      description: editDescription,
      dueDate: editDueDate,
    });
    setIsEditing(false);
  };

  const handleCancel = () => {
    setEditTitle(task.title);
    setEditDescription(task.description);
    setEditDueDate(task.dueDate);
    setIsEditing(false);
  };

  return (
    <li
      className={`p-3 mb-2 border rounded ${
        task.completed ? "bg-gray-50" : "bg-white"
      }`}
    >
      {isEditing ? (
        <div className="space-y-2">
          <div className="flex">
            <input
              type="text"
              value={editTitle}
              onChange={(e) => setEditTitle(e.target.value)}
              className="flex-grow p-1 border rounded"
              autoFocus
            />
            <input
              type="date"
              value={editDueDate}
              onChange={(e) => setEditDueDate(e.target.value)}
              className="ml-2 p-1 border rounded"
            />
          </div>
          <textarea
            value={editDescription}
            onChange={(e) => setEditDescription(e.target.value)}
            className="w-full p-1 border rounded"
            rows="2"
          />
          <div className="flex justify-end space-x-2">
            <button
              onClick={handleSave}
              className="px-2 py-1 bg-green-500 text-white rounded hover:bg-green-600"
              type="button"
            >
              保存
            </button>
            <button
              onClick={handleCancel}
              className="px-2 py-1 bg-gray-300 rounded hover:bg-gray-400"
              type="button"
            >
              キャンセル
            </button>
          </div>
        </div>
      ) : (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                type="checkbox"
                checked={task.completed}
                onChange={() => onToggleComplete(task.id)}
                className="mr-3 h-5 w-5"
              />
              <div>
                <span className={task.completed ? "line-through text-gray-500" : ""}>
                  {task.title}
                </span>
                {task.dueDate && (
                  <span className="ml-2 text-xs text-gray-500">
                    期限: {new Date(task.dueDate).toLocaleDateString()}
                  </span>
                )}
              </div>
            </div>
            <div className="flex items-center space-x-2">
              <span className="text-xs text-gray-500">
                {task.dueDate}
              </span>
              <button
                onClick={() => setIsEditing(true)}
                className="px-2 py-1 bg-yellow-100 rounded hover:bg-yellow-200 text-yellow-600"
                type="button"
              >
                編集
              </button>
              <button
                onClick={() => onDelete(task.id)}
                className="px-2 py-1 bg-red-100 rounded hover:bg-red-200 text-red-600"
                type="button"
              >
                削除
              </button>
            </div>
          </div>
          {task.description && (
            <p className="text-sm text-gray-600 ml-8">{task.description}</p>
          )}
        </div>
      )}
    </li>
  );
};

export default TaskItem; 
```

#### Reactタスク管理コンポーネントの解説

このコンポーネントは、タスク管理アプリでの1つのタスク項目を表示するためのものです。タスクの表示、編集、完了のマーク付け、削除などの機能を持っています。
##### 基本構造
```tsx
const TaskItem = ({ task, onToggleComplete, onDelete, onUpdate }) => {
  // ステート（状態）の定義
  // コンポーネントの表示や機能
  return (
    // JSX（見た目の部分）
  );
};
```
##### 主要な機能と概念
1. Propsの受け取り
```tsx
const TaskItem = ({ task, onToggleComplete, onDelete, onUpdate }) => {
```

- task: 表示するタスクのデータ（タイトル、説明、期限日など）
- onToggleComplete: タスク完了状態を切り替える関数
- onDelete: タスクを削除する関数
- onUpdate: タスク情報を更新する関数

これらは親コンポーネントから渡されるもので、このコンポーネント内での操作を親コンポーネントに伝えるために使います。

2. ステート（状態）管理

```tsx
const [isEditing, setIsEditing] = useState(false);
const [editTitle, setEditTitle] = useState(task.title);
const [editDescription, setEditDescription] = useState(task.description);
const [editDueDate, setEditDueDate] = useState(task.dueDate);
```
- useStateはReactのフック（Hook）で、コンポーネントに状態を追加します
- isEditing: 編集モードかどうかを示す真偽値
- editTitle, editDescription, editDueDate: 編集中のタスク情報を一時的に保存

これらの状態が変わると、コンポーネントが自動的に再描画されます。

3. イベントハンドラー関数
```tsx
const handleSave = () => {
  onUpdate(task.id, {
    title: editTitle,
    description: editDescription,
    dueDate: editDueDate,
  });
  setIsEditing(false);
};

const handleCancel = () => {
  setEditTitle(task.title);
  setEditDescription(task.description);
  setEditDueDate(task.dueDate);
  setIsEditing(false);
};
```

- handleSave: 編集内容を保存する関数
- handleCancel: 編集をキャンセルして元の値に戻す関数

4. 条件付きレンダリング
```tsx
return (
  <li className={`p-3 mb-2 border rounded ${
    task.completed ? "bg-gray-50" : "bg-white"
  }`}>
    {isEditing ? (
      // 編集モードの表示
    ) : (
      // 通常表示モード
    )}
  </li>
);
```

- isEditingの値によって、表示内容が切り替わります
- ? :は三項演算子で、条件によって異なるJSXを返します

5. フォーム要素と双方向バインディング
```tsx
<input
  type="text"
  value={editTitle}
  onChange={(e) => setEditTitle(e.target.value)}
  className="flex-grow p-1 border rounded"
  autoFocus
/>
```

- value={editTitle}: ステートの値をフォーム要素に表示
- onChange={(e) => setEditTitle(e.target.value)}: 入力内容が変わったらステートを更新
  - これにより、入力フィールドとステートが同期します（双方向バインディング）


#### 画面操作
ここまでできたら画面を操作してみましょう。
- 先ほど追加したタスクが表示されるか
  - ![react](image7.png)
- もう1件タスク追加
  - ![react](image8.png)
- タスクの更新
  - 編集ボタンを押下し、タスクタイトル、タスク詳細を更新する
  - ![react](image9.png)
  - 編集後、保存ボタンを押下し内容が更新されていることを確認する
- タスクの完了
  - チェックボックスをクリックして完了に更新する。
  - ![react](image10.png)
- タスクの削除
  - 先ほど更新したタスクの削除ボタンを押下し、タスクを削除する
  - ![react](image11.png)
  - タスクが1件になっていることを確認する。

#### TaskFilters.jsx

`src/App.jsx`を更新します。

```jsx
'use client';

import React from 'react';
import { useTaskManager } from '../hooks/useTaskManager';
import TaskForm from '../components/TaskForm';
import TaskList from '../components/TaskList';
import TaskFilters from '../components/TaskFilters'; // 追加

const App = () => {
  const {
    addTask,
    tasks,
    updateTask,
    deleteTask,
    toggleComplete,
    // filteredTasks,filter,setFilter,markAll,clearCompletedの追加
    filteredTasks,
    filter,
    setFilter,
    markAll,
    clearCompleted,
  } = useTaskManager();
  return (
    <div className="mx-auto flex max-w-2xl flex-col items-center rounded-lg bg-white p-4 shadow">
      <h1 className="mb-4 text-2xl font-bold">タスク管理アプリ</h1>
      <TaskForm onAddTask={addTask} />
      {/* ---------TaskFiltersの追加ここから----------- */}
      <TaskFilters
        filter={filter}
        setFilter={setFilter}
        markAll={markAll}
        clearCompleted={clearCompleted}
      />
      <div className="mt-4 w-full text-sm text-gray-500">
        全タスク: {tasks.length} | 完了済み:{' '}
        {tasks.filter(t => t.completed).length} | 未完了:{' '}
        {tasks.filter(t => !t.completed).length}
      </div>
      {/* ---------TaskFiltersの追加ここまで----------- */}
      <TaskList
        tasks={filteredTasks} // ここをフィルター結果を表示できるように更新！！！
        onToggleComplete={toggleComplete}
        onDelete={deleteTask}
        onUpdate={updateTask}
      />
    </div>
  );
};

export default App;

```


`src/hooks/useTaskManager.js`の編集をします。
```javascript
import { useState, useEffect } from "react";

export const useTaskManager = () => {
  const [tasks, setTasks] = useState(() => {
    const savedTasks = localStorage.getItem("tasks");
    return savedTasks ? JSON.parse(savedTasks) : [];
  });

  const [filter, setFilter] = useState("all"); // filterの追加


  useEffect(() => {
    localStorage.setItem("tasks", JSON.stringify(tasks));
  }, [tasks]);

  const addTask = (title, description = "", dueDate = "") => {
    if (!title.trim()) return;

    const newTask = {
      id: Date.now(),
      title,
      description,
      dueDate,
      completed: false,
    };

    setTasks([...tasks, newTask]);
  };

  const updateTask = (id, updates) => {
    setTasks(
      tasks.map((task) => (task.id === id ? { ...task, ...updates } : task))
    );
  };

  const deleteTask = (id) => {
    setTasks(tasks.filter((task) => task.id !== id));
  };

  const toggleComplete = (id) => {
    setTasks(
      tasks.map((task) =>
        task.id === id ? { ...task, completed: !task.completed } : task
      )
    );
  };

  // ---------------ここから追加--------------------
  const markAll = (completed) => {
    setTasks(tasks.map((task) => ({ ...task, completed })));
  };

  const clearCompleted = () => {
    setTasks(tasks.filter((task) => !task.completed));
  };

  const filteredTasks = tasks.filter((task) => {
    if (filter === "active") return !task.completed;
    if (filter === "completed") return task.completed;
    return true;
  });
  // ---------------ここまで追加--------------------

  return { 
    addTask,
    tasks,
    deleteTask,
    toggleComplete,
    updateTask, 
    // filteredTasks,filter,setFilter,markAll,clearCompletedの追加
    filteredTasks,
    filter,
    setFilter,
    markAll,
    clearCompleted,
  };
};

```

1. markAll関数 - 全タスクの状態を一括設定
```javascript
const markAll = (completed) => {
  setTasks(tasks.map((task) => ({ ...task, completed })));
};
```

#### 機能
- すべてのタスクの完了状態を一度に変更します（全部完了にする/全部未完了にするなど）。
#### 詳しい解説
- completed: 設定したい完了状態（trueまたはfalse）
- tasks.map(): タスク配列の全要素に対して処理を行う
- ({ ...task, completed }):
  - 各タスクのすべてのプロパティを維持しながら（...task）
  - completedプロパティだけを新しい値に更新

この関数を使うと、「すべて完了にする」や「すべて未完了にする」ボタンが実装できます


2. clearCompleted関数 - 完了済みタスクの一括削除
```javascript
const clearCompleted = () => {
  setTasks(tasks.filter((task) => !task.completed));
};
```
#### 機能
- 完了済み（completed = true）のタスクをすべて削除します。

#### 詳しい解説

- tasks.filter(): 条件に合うタスクだけを残して新しい配列を作る
- (task) => !task.completed:
  - 未完了のタスク（completedがfalseのもの）だけを残す条件
  - つまり、完了済みのタスクはすべて除外される

この関数は「完了したタスクをクリア」ボタンなどに使えます


3. filteredTasks - フィルター機能の実装
```javascript
const filteredTasks = tasks.filter((task) => {
  if (filter === "active") return !task.completed;
  if (filter === "completed") return task.completed;
  return true;
});
```

#### 機能
- タスク一覧を「すべて」「未完了のみ」「完了済みのみ」で絞り込みます。

#### 詳しい解説
- filterという状態変数（上部のuseStateで追加）に基づいてタスクをフィルタリング
  - 3つのフィルター条件：
    - "active": 未完了のタスクのみ表示 （!task.completedがtrueのもの）
    - "completed": 完了済みのタスクのみ表示 （task.completedがtrueのもの）
    - それ以外（"all"など）: すべてのタスクを表示 （条件なし）

結果はfilteredTasksとして返され、これをタスク一覧表示に使用します


`src/components/TaskFilters.jsx`コンポーネントを編集する。
```jsx
import React from "react";

const TaskFilters = ({ filter, setFilter, markAll, clearCompleted }) => {
  return (
    <div className="w-full mb-4 flex justify-between items-center">
      <div className="flex space-x-2">
        <button
          onClick={() => setFilter("all")}
          className={`px-3 py-1 rounded ${
            filter === "all" ? "bg-blue-500 text-white" : "bg-gray-200"
          }`}
          type="button"
        >
          全て
        </button>
        <button
          onClick={() => setFilter("active")}
          className={`px-3 py-1 rounded ${
            filter === "active" ? "bg-blue-500 text-white" : "bg-gray-200"
          }`}
          type="button"
        >
          未完了
        </button>
        <button
          onClick={() => setFilter("completed")}
          className={`px-3 py-1 rounded ${
            filter === "completed" ? "bg-blue-500 text-white" : "bg-gray-200"
          }`}
          type="button"
        >
          完了済み
        </button>
      </div>

      <div className="flex space-x-2">
        <button
          onClick={() => markAll(true)}
          className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300"
          type="button"
        >
          全て完了
        </button>
        <button
          onClick={() => markAll(false)}
          className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300"
          type="button"
        >
          全て未完了
        </button>
        <button
          onClick={clearCompleted}
          className="px-3 py-1 bg-red-100 rounded hover:bg-red-200 text-red-600"
          type="button"
        >
          完了を削除
        </button>
      </div>
    </div>
  );
};

export default TaskFilters;

```

ここまでできたら画面を操作してみましょう。
- まずタスクを何件か追加する
- そのうち何件かのタスクを完了にする
- フィルターの確認で、全て、未完了、完了済みのそれぞれで絞込みをする
- 全て完了、全て未完了ボタンを押下して、一括更新できるか確認する
- 完了のタスクを一括削除する


#### TaskHelper.jsx

`src/App.jsx`を更新します。

```jsx
'use client';

import React from 'react';
import { useTaskManager } from '../hooks/useTaskManager';
import TaskForm from '../components/TaskForm';
import TaskList from '../components/TaskList';
import TaskFilters from '../components/TaskFilters';
import AITaskHelper from "../components/TaskHelper"; // 追加

const App = () => {
  const {
    addTask,
    tasks,
    updateTask,
    deleteTask,
    toggleComplete,
    filteredTasks,
    filter,
    setFilter,
    markAll,
    clearCompleted,
  } = useTaskManager();
  return (
    <div className="mx-auto flex max-w-2xl flex-col items-center rounded-lg bg-white p-4 shadow">
      <h1 className="mb-4 text-2xl font-bold">タスク管理アプリ</h1>
      <TaskForm onAddTask={addTask} />
      <TaskFilters
        filter={filter}
        setFilter={setFilter}
        markAll={markAll}
        clearCompleted={clearCompleted}
      />
      <div className="mt-4 w-full text-sm text-gray-500">
        全タスク: {tasks.length} | 完了済み:{' '}
        {tasks.filter(t => t.completed).length} | 未完了:{' '}
        {tasks.filter(t => !t.completed).length}
      </div>
      <TaskList
        tasks={filteredTasks}
        onToggleComplete={toggleComplete}
        onDelete={deleteTask}
        onUpdate={updateTask}
      />
      {/* ---------AITaskHelperの追加ここから----------- */}
      <AITaskHelper filteredTasks={filteredTasks} />
      {/* ---------AITaskHelperの追加ここまで----------- */}
    </div>
  );
};

export default App;

```

`src/app/api/ai-tasks/route.js`

```javascript
import { NextResponse } from 'next/server';

export async function POST(request) {
  try {
    const endpoint = process.env.REACT_APP_AZURE_OPENAI_ENDPOINT;
    const apiKey = process.env.REACT_APP_AZURE_OPENAI_KEY;

    if (!endpoint || !apiKey) {
      console.error('環境変数が設定されていません:', {
        endpoint: !!endpoint,
        apiKey: !!apiKey,
      });
      return NextResponse.json(
        {
          error:
            '環境変数の設定が不足しています。サーバー管理者にお問い合わせください。',
        },
        { status: 500 }
      );
    }
    const { prompt, tasks } = await request.json();

    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'api-key': apiKey,
      },
      body: JSON.stringify({
        messages: [
          { role: 'system', content: 'あなたはタスク管理の専門家です。' },
          {
            role: 'user',
            content: `
              あなたはタスク管理マネージャーです。
              「# ユーザーの指示」に回答する際に「# タスク一覧」をもとに回答を生成してください。
              タスク一覧が持つ情報については以下の通りになります。
              # タスク情報
              - id: タスクのIDで、タスクごとに一意になる
              - title: タスクのタイトル
              - description: タスクの詳細説明
              - dueDate: タスクの期限日
              - completed: タスクの完了状況
              
              # タスク一覧
              - ${JSON.stringify(tasks)}

              # ユーザーの指示
              ${prompt}
            `,
          },
        ],
        max_tokens: 150,
        temperature: 0.7,
      }),
    });

    if (!response.ok) {
      throw new Error(`API responded with status: ${response.status}`);
    }

    const data = await response.json();
    return NextResponse.json({ result: data.choices[0].message.content });
  } catch (error) {
    console.error('Azure OpenAI API error:', error);
    return NextResponse.json(
      { error: 'エラーが発生しました。もう一度お試しください。' },
      { status: 500 }
    );
  }
}

```

##### 全体の役割
このコードは、フロントエンドからのリクエストを受け取り、Azure OpenAIのAPIを使ってタスク管理に関する質問に回答し、その結果をフロントエンドに返す役割を持っています。

##### コードの詳細解説

1. インポート部分
```javascript
import { NextResponse } from 'next/server';
```

NextResponseは、Next.jsのAPIルートでレスポンスを返すための機能です。

HTTPレスポンスを簡単に作成できます。

2. APIハンドラー関数
```javascript
export async function POST(request) {
  // 処理の内容
}
```

- Next.jsのAPIルートでは、HTTPメソッド名（ここではPOST）と同じ名前の関数をエクスポートします
- この関数は、クライアントからのPOSTリクエストを処理します
- asyncキーワードがついているので、非同期処理（APIリクエストなど時間のかかる処理）ができます

3. 環境変数の確認
```javascript
const endpoint = process.env.REACT_APP_AZURE_OPENAI_ENDPOINT;
const apiKey = process.env.REACT_APP_AZURE_OPENAI_KEY;

if (!endpoint || !apiKey) {
  // エラー処理
}

```

環境変数からAzure OpenAIのエンドポイントとAPIキーを取得しています

もし設定されていなければエラーメッセージを返します

4. リクエストからデータを取得
```javascript
const { prompt, tasks } = await request.json();
```

クライアントから送られてきたJSONデータから、prompt（ユーザーの質問）とtasks（タスク一覧）を取り出しています

5. Azure OpenAI APIへのリクエスト

```javascript
const response = await fetch(endpoint, {
  method: 'POST',
  headers: { /* ヘッダー情報 */ },
  body: JSON.stringify({ /* リクエストボディ */ }),
});
```

Azure OpenAI APIにリクエストを送っています

システムプロンプト（タスク管理の専門家という設定）とユーザープロンプト（タスク一覧と質問）を含めています

max_tokens: 150は回答の最大長、temperature: 0.7は回答のランダム性を示します

6. レスポンス処理
```javascript
const data = await response.json();
return NextResponse.json({ result: data.choices[0].message.content });
```

APIからの応答をJSONに変換し、応答内容をクライアントに返します

7. エラーハンドリング
```javascript
try {
  // 処理内容
} catch (error) {
  // エラー時の処理
}
```

処理中にエラーが発生した場合、適切なエラーメッセージを返します

`src/hooks/useAiTask.js`を追加
```javascript
// hooks/useAiTask.js
export const useAiTask = (setResult, setIsLoading) => {
  // Next.jsのAPIルートを呼び出す関数
  const DescriptionTaskByAi = async (prompt, tasks) => {
    setIsLoading(true);

    try {
      // 内部APIルートを呼び出す
      const response = await fetch('/api/ai-tasks', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          prompt,
          tasks,
        }),
      });

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const data = await response.json();
      setResult(data.result);
    } catch (error) {
      console.error('API error:', error);
      setResult('エラーが発生しました。もう一度お試しください。');
    } finally {
      setIsLoading(false);
    }
  };

  return { DescriptionTaskByAi };
};

```

#### コードの詳細解説
##### 1. カスタムフックの定義
```javascript
export const useAiTask = (setResult, setIsLoading) => {
  return { DescriptionTaskByAi };
};
```

- useAiTaskというカスタムフックを定義しています

- 引数としてsetResultとsetIsLoadingという2つの関数を受け取ります

- これらは通常、ReactのuseStateフックで生成されたステート更新関数です
  - setResult: AI応答の結果を保存するための関数
  - setIsLoading: 読み込み状態を管理するための関数


##### 2. 内部のAPI呼び出し関数
```javascript
const DescriptionTaskByAi = async (prompt, tasks) => {
  setIsLoading(true);
  
  try {
    // API呼び出しのロジック
    // ...
  } catch (error) {
    // エラー処理
    // ...
  } finally {
    setIsLoading(false);
  }
};

```

- このフック内でDescriptionTaskByAiという非同期関数を定義しています
- 引数としてprompt（ユーザーの指示）とtasks（タスク一覧）を受け取ります
- 処理の開始時にsetIsLoading(true)で読み込み状態をオンにします
- 最後のfinallyブロックで、成功しても失敗しても必ずsetIsLoading(false)を実行します

##### 3. APIリクエストの実行
```javascript
const response = await fetch('/api/ai-tasks', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    prompt,
    tasks,
  }),
});
```

- 内部のNext.jsのAPIルート /api/ai-tasks にPOSTリクエストを送信しています
- リクエストボディにpromptとtasksをJSON形式で含めています
- このAPIルートは、前回のコードで説明したサーバーサイドの処理を実行します

##### 4. レスポンス処理
```javascript
const data = await response.json();
setResult(data.result);
```

- APIからのレスポンスをJSON形式で取得します
- data.result（AI生成テキスト）をsetResult関数を使ってステートに保存します

##### 5. エラーハンドリング
```javascript
if (!response.ok) {
  throw new Error(`API responded with status: ${response.status}`);
}
```
```javascript
catch (error) {
  console.error('API error:', error);
  setResult('エラーが発生しました。もう一度お試しください。');
}
```

- HTTPステータスが成功（200-299）でない場合はエラーを投げます
- エラー発生時は、コンソールにエラーを記録し、ユーザーに表示するエラーメッセージを設定します

`src/components/TaskHelper.jsx`の追加

```jsx
import React, { useState } from "react";
import { useAiTask } from "../hooks/useAiTask";

const AITaskHelper = ({ filteredTasks }) => {
  const [input, setInput] = useState("");
  const [result, setResult] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const { DescriptionTaskByAi } = useAiTask(setResult, setIsLoading);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!input.trim()) return;

    DescriptionTaskByAi(input, filteredTasks);
  };

  return (
    <div className="w-full p-4 border rounded shadow">
      <h2 className="text-xl font-bold mb-4">AIタスクヘルパー</h2>

      <form onSubmit={handleSubmit} className="mb-4">
        <div className="flex">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="タスクについて質問してください..."
            className="flex-grow p-2 border rounded-l"
          />
          <button
            type="submit"
            className="bg-blue-500 text-white px-4 py-2 rounded-r"
            disabled={isLoading}
          >
            {isLoading ? "処理中..." : "送信"}
          </button>
        </div>
      </form>
      <div className="mt-4 p-3 bg-gray-50 rounded">
        <h3 className="font-semibold mb-2">AIの提案:</h3>
        <p>{result}</p>
      </div>
    </div>
  );
};

export default AITaskHelper;

```
#### 基本的な機能
AITaskHelperコンポーネントの主な機能は：

- ユーザーがAIにタスクについて質問できる入力フォームを提供
- 入力内容をAIに送信して分析してもらう
- AIからの提案や回答を表示する

コンポーネントの定義
```jsx
const AITaskHelper = ({ filteredTasks }) => {
  // 中身はこの後に続きます
};
```
このコンポーネントは1つのpropを受け取ります：

- filteredTasks: 現在表示されているタスクのリスト（AIに分析させるデータ）

#### 状態（state）の管理
```jsx
const [input, setInput] = useState("");
const [result, setResult] = useState("");
const [isLoading, setIsLoading] = useState(false);
```

3つの状態変数を使用しています：

- input: ユーザーが入力した質問やプロンプト
- result: AIからの応答結果
- isLoading: AIとの通信中かどうかを示すフラグ


#### フォーム部分の詳細
```jsx
<form onSubmit={handleSubmit} className="mb-4">
  <div className="flex">
    <input
      type="text"
      value={input}
      onChange={(e) => setInput(e.target.value)}
      placeholder="タスクについて質問してください..."
      className="flex-grow p-2 border rounded-l"
    />
    <button
      type="submit"
      className="bg-blue-500 text-white px-4 py-2 rounded-r"
      disabled={isLoading}
    >
      {isLoading ? "処理中..." : "送信"}
    </button>
  </div>
</form>
```

ここでは：
- テキスト入力欄：
  - value={input}: 現在の入力内容を表示
  - onChange: 入力が変更されるたびにsetInputで状態を更新
  - placeholder: 入力例を示すヒントテキスト
- 送信ボタン：
  - disabled={isLoading}: 処理中は押せないようにする
  - ボタンのテキストはロード中かどうかで変化（「処理中...」または「送信」）
  - 青い背景色と白いテキスト


## 2.3 環境変数の設定とAzure AI Foundryで作成したAPIの動作確認
Azure AI FoundryのAPIを呼び出すには環境変数で、エンドポイントやAPIキーを登録する必要があります。

Azure AI Foundryプロジェクトを作成（第3回のスライドで確認）

プロジェクトが完成したらチャットプレイグラウンドを開きます。

コードの表示メニューをクリックします。
開いたら、キー認証を選択してください。

![react](image20.png)

下にスクロールするとエンドポイントとAPIキーが表示されています。

![react](image21.png)

こちらをCodesandboxの方に環境変数として登録していきます。
`src/app/api/ai-tasks/route.js`のコードの中で出現する環境変数は以下の2つです。
- REACT_APP_AZURE_OPENAI_ENDPOINT
- REACT_APP_AZURE_OPENAI_KEY

ルートディレクトリに`.env`ファイルを作成します。
```
REACT_APP_AZURE_OPENAI_KEY="Azure AI Foundryで確認したあなたのキーを設定してください。"
REACT_APP_AZURE_OPENAI_ENDPOINT="Azure AI Foundryで確認したあなたのエンドポイントを設定してください"
```

上記のような機密情報は通常コミットファイルには含めたくありません。
プライベートリポジトリのため、外部に漏れる可能性はほぼありませんが、環境変数はGithubで管理しないことを強くお勧めします。

そのため、ルートディレクトリの`.gitignore`ファイルの末尾に以下の1行を追加してください。

```
.env
```
`.gitignore`ファイルに記載したファイルは変更履歴の対象外となります。


それでは、AIタスクヘルパーに以下のように入力してテストしてみましょう。

![react](image24.png)

上記のようにAzure AI Foundryで作成したモデルをReact側から呼び出すことができました。

# 追加課題
- AIタスクヘルパーに色々な質問をしてみましょう。
  - 現状のAIタスクヘルパーの課題を列挙しましょう。
- 上記の課題を解決するためにAPIで呼び出しているプロンプトを改善してみましょう。
  - 改善のポイント
    - 例や変数の追加
    - 出力形式の指定
    - ハルシネーション対策
    - temperatureやmax_tokensの調整
      などなど、、、
  - 改善のためのおすすめ手順
    - Azure AI Foundryのチャットプレイグラウンドで検証
    - サンプルコードを見て、それらを参考に`app/api/ai-task/route.js`の実装に反映させる
